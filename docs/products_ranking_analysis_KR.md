# 프로젝트 분석: 상품 순위 자동화 (Products Ranking Automation)

이 문서는 `products_ranking` 파이썬 프로젝트에 대한 상세 분석을 제공합니다. 각 파일의 역할, 상세 구현 로직 및 모듈 간의 관계를 다룹니다.

## 1. 파일별 역할 및 상세 구현 로직

### 1.1 `config.py`
**역할**: 중앙 설정 관리
**설명**: 전역 상수, 파일 경로 및 계정 정보를 저장합니다. 프로젝트가 일반 스크립트나 PyInstaller로 빌드된 실행 파일(.exe) 형태 모두에서 정상적으로 동작하도록 보장합니다.

**핵심 로직**:
- **경로 확인**: 빌드된 상태라면 `sys.executable`을, 아니라면 `__file__`을 사용하여 `BASE_DIR`을 결정합니다.
- **주요 상수**:
    - `EXCEL_PATH`: `TOP★점프_트래픽관리.xlsm` (대상 엑셀 파일)
    - `TOP_ADS_URL`: `https://top.re.kr/ads` (대상 웹 사이트)
    - `MAX_PAGES`: 5 (수집할 최대 페이지 수 제한)
    - `ACCOUNT`: 하드코딩된 계정 정보 (`sstrade251016`).

### 1.2 `excel_handler.py`
**역할**: 엑셀 상호작용 관리
**설명**: 엑셀에서 제약 조건을 읽고 수집된 순위 결과를 다시 작성하는 일을 담당합니다. 주로 `xlwings`를 사용하여 실행 중인 엑셀 인스턴스와 통신하며, 매크로(`.xlsm`)와 외부 링크를 보존합니다.

**상세 로직**:
- **`sync_date_columns_until_today(ws)`**:
    - `2026-01-01`부터 오늘까지 날짜를 반복 확인합니다.
    - 5행에서 기존 날짜 헤더가 있는지 확인합니다.
    - **로직**: 날짜 열이 없으면 특정 마커 열("직전", "비고", "서식") 왼쪽이나 끝에 **새 열을 동적으로 삽입**합니다. 이를 통해 우측의 고정 수식을 깨뜨리지 않고 시트를 확장합니다.
- **`get_dates_requiring_update(ws)`**:
    - **로직 특징 (전부 아니면 전무)**: 각 날짜 열을 확인하여, 해당 날짜의 **"순위" 행(Q열 기준)이 완전히 비어 있는 경우에만** 업데이트 대상 목록에 추가합니다.
    - *참고*: 특정 날짜에 상품 순위가 하나라도 기록되어 있으면 해당 날짜는 통째로 건너뜁니다. 이는 성능 최적화를 위한 것이지만, 중간에 중단된 작업은 수동으로 처리해야 함을 의미합니다.
- **`update_excel_rank_fast(ws, ...)`**:
    - 미리 계산된 인덱스를 사용하여 O(1) 속도로 업데이트를 수행합니다.
    - `(row_num, target_col)` 위치의 셀에 새로운 순위를 입력합니다.
- **`build_row_index(ws)`**:
    - F열(상품 ID)과 J열(키워드)을 스캔합니다.
    - 매핑: `{(상품 ID, 키워드) -> 행 번호}`.
    - 이 전처리 과정은 매 결과마다 행을 하나씩 검색하는 것보다 쓰기 속도를 획기적으로 향상시킵니다.

### 1.3 `web_handler.py`
**역할**: 웹 자동화 (Selenium)
**설명**: 크롬 브라우저의 생명 주기를 관리하고, `top.re.kr` 사이트를 탐색하며 순위 데이터를 추출합니다.

**상세 로직**:
- **`create_driver`**: 봇 감지를 피하기 위해 `automationControlled`를 비활성화한 상태로 크롬을 초기화합니다. 영구적인 사용자 프로필 디렉토리를 사용합니다.
- **`extract_normal_products(driver, target_dates)`**:
    - **필터링 로직**: "정상" 탭으로 이동하여 현재 활성화된 상품들을 찾습니다.
    - **날짜 의존성**: 내부적으로 `extract_product_results`를 호출하므로, 타겟 날짜 범위 내에서 활성화된 "정상" 상품만 식별합니다.
- **`extract_product_results(driver, target_dates)`**:
    - 1000개씩 보기 설정이 된 테이블을 스캔합니다.
    - **날짜 필터링**: 각 행의 "시작일"과 "종료일"을 파싱합니다.
    - **일치 로직**: `시작일 <= 타겟 날짜 <= 종료일` 여부를 확인합니다. 상품이 특정 타겟 날짜에 활성 상태인 경우에만 기록을 생성합니다.
    - 추출 항목: `행 키워드`, `상품 ID` (URL에서 추출), `순위`.
- **`login_success_check`**: 최대 3회 재시도 및 "로그아웃" 버튼 가시성 확인을 통해 견고한 로그인 흐름을 구현합니다.

### 1.4 `main.py`
**역할**: 오케스트레이터 (조율자)
**설명**: 엑셀 준비, 웹 수집, 엑셀 업데이트 단계를 하나로 연결합니다.

**실행 흐름**:
1.  **엑셀 준비**: 엑셀을 열고 날짜 열을 동기화하며, 데이터가 전혀 없는 날짜를 식별합니다.
    - *조건*: 업데이트가 필요한 날짜가 없으면 즉시 종료합니다.
2.  **환경 준비**: 기존 크롬 프로세스를 종료하고 특정 캐시 폴더(`Default/Cache`, `Code Cache` 등)를 삭제하여 깨끗한 브라우저 상태를 보장합니다.
3.  **탐색**: 로그인 후 활성화된 "정상" 상품들을 수집하여 대상 `상품 ID` 목록을 만듭니다.
4.  **대상별 수집 (루프)**:
    - 발견된 각 고유 `상품 ID`에 대해:
        - 도움 함수: `search_keyword(ID)`를 통해 필터를 초기화하고 해당 ID만 검색합니다.
        - 동작: `extract_product_results`가 해당 ID에 대한 모든 순위 정보(타겟 날짜 대조)를 가져옵니다.
        - **기록**: 빠른 인덱스 조회를 사용하여 메모리 상의 엑셀 객체(`xlwings`)를 즉시 업데이트합니다.
5.  **커밋**: 모든 루프가 끝난 후 엑셀 파일을 저장(`wb.save()`)합니다.
6.  **정리**: 엑셀 연결과 크롬 드라이버를 닫습니다.

## 2. 로직 흐름 및 관계도

시스템은 선형적인 배치 처리 모델을 따릅니다.

```mermaid
flowchart TD
    subgraph Initialization [초기화]
        A[main.py 시작] --> B[config.py: 설정 로드]
        A --> C[excel_handler: .xlsm 열기]
        C --> D[excel_handler: 날짜 열 동기화]
        D --> E{업데이트 필요 날짜?}
        E -- 없음 --> F[프로그램 종료]
    end

    subgraph Preparation [준비]
        E -- 있음 --> G[excel_handler: 행 인덱스 구축]
        G --> H[web_handler: 캐시 삭제 및 크롬 종료]
        H --> I[web_handler: 크롬 실행 및 로그인]
    end

    subgraph Discovery [탐색]
        I --> J[web_handler: '정상' 상품 추출]
        J --> K[고유 상품 ID 식별]
    end

    subgraph Scraping_Loop [수집 루프: 각 상품 ID별]
        K --> L[web_handler: ID로 검색]
        L --> M[web_handler: 순위 추출 (날짜 필터링)]
        M --> N[excel_handler: 셀 업데이트 (빠른 인덱스)]
    end

    subgraph Finalization [완료]
        N --> O_Loop{남은 ID가 있는가?}
        O_Loop -- 있음 --> L
        O_Loop -- 없음 --> P[excel_handler: 파일 저장]
        P --> Q[리소스 해제 및 종료]
    end
```

### 주요 의존성
- **`main.py`**는 **컨트롤러(Controller)**입니다: 다른 모든 모듈을 가져오고 지시합니다.
- **`web_handler.py`**는 **제공자(Provider)**입니다: 데이터(순위)를 제공하지만 엑셀 구조에 대해서는 알지 못합니다.
- **`excel_handler.py`**는 **저장소(Storage)**입니다: 엑셀 구조(행, 열, 날짜)를 알고 있지만 웹 소스에 대해서는 알지 못합니다.
- **`config.py`**는 **공유 정보(Shared Truth)**입니다: 두 핸들러 모두 경로와 기본 설정을 위해 이를 사용합니다.

### 중요한 로직 관찰 사항
1.  **부분 업데이트 위험**: 루프 중간에 스크립트가 충돌하면 특정 날짜의 일부 상품만 업데이트될 수 있습니다. `get_dates_requiring_update`는 데이터가 *조금이라도* 있으면 해당 날짜를 건너뛰므로, 재실행 시 부분적으로 채워진 날짜는 누락될 수 있습니다.
2.  **날짜 중심 필터링**: 상품의 "광고 기간"(시작~종료)이 타겟 날짜를 포함하는 경우에만 추적됩니다. 이미 종료된 광고 상품은 `extract_product_results`에 의해 자동으로 무시됩니다.
